<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>VexCode Introduction - Harvard-Westlake VEX Robotics</title>
  <meta name="description" content="Learn the VEX programming environment and basic robot control. Get started with VEXcode IDE and master the fundamentals of VEX programming.">
  <link rel="stylesheet" href="assets/main.css">
  
  <!-- Prism.js for syntax highlighting -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
  
  <!-- Theme toggle script -->
  <script src="assets/theme-toggle.js" defer></script>
  
  <!-- Prevent flash of unstyled content -->
  <script>
    (function() {
      const theme = localStorage.getItem('hw-vexcode-theme') || 
                   (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
      document.documentElement.setAttribute('data-theme', theme);
    })();
  </script>
</head>

<body>
  <header class="site-header" role="banner">
    <div class="wrapper">
      <a class="site-title" rel="author" href="index.html">Harvard-Westlake VEX Robotics</a>

      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          <a class="page-link" href="index.html">Home</a>
          <a class="page-link" href="cs-overview.html">Computer Science Overview</a>
          <a class="page-link" href="vexcode-introduction.html">VEXcode Introduction</a>
          <a class="page-link" href="advanced-robotics-programming.html">Advanced Robotics Programming</a>
        </div>
      </nav>
    </div>
  </header>

  <main class="page-content" aria-label="Content">
    <div class="wrapper">
      <div class="layout--sidebar">
        <aside class="sidebar">
          <div class="sidebar-inner">
            <h3 class="sidebar-title">On this page</h3>
            <nav class="sidebar-nav">
              <ul id="sidebar-nav-list">
                <!-- Navigation will be generated by JavaScript -->
              </ul>
            </nav>
          </div>
        </aside>
        <main class="sidebar-content">
          <article class="post">
            <header class="post-header">
              <h1 class="post-title">VexCode Introduction</h1>
            </header>
            <div class="post-content">
              <h2 id="what-is-vexcode">What is VexCode?</h2>

              <p>VexCode is the official programming environment for VEX Robotics competitions. While VexCode traditionally refers to the standalone IDE, we'll be using the <strong>VexCode extension for Visual Studio Code</strong>, which provides a more professional development experience with better code management and team collaboration.</p>

              <blockquote>
                <p><strong>Key Features of VexCode VS Code Extension:</strong></p>
                <ul>
                  <li>Full C++ development environment in VS Code</li>
                  <li>Built-in VEX API support and autocomplete</li>
                  <li>Real-time error checking and syntax highlighting</li>
                  <li>Code-based device configuration (no visual tools needed)</li>
                  <li>Built-in documentation and IntelliSense</li>
                  <li>Direct upload to V5 Brain</li>
                  <li>Git integration for team collaboration</li>
                  <li>Competition-ready program structure</li>
                </ul>
              </blockquote>

              <h2 id="competition-program-structure">Competition Program Structure</h2>

              <p><strong>Every VEX program starts with <code>int main()</code></strong> - this is where your program begins execution. However, for competition robotics, we use a special structure that separates autonomous and driver control periods.</p>

              <pre><code class="language-cpp">#include "vex.h"

using namespace vex;

int main() {
    // Competition initialization
    Competition.autonomous(autonomous);
    Competition.drivercontrol(usercontrol);
    
    // Pre-autonomous setup
    pre_auton();
    
    // Main competition loop
    while (true) {
        wait(100, msec);
    }
}</code></pre>

              <p><strong>Understanding the Competition Structure:</strong></p>
              <ul>
                <li><strong><code>autonomous()</code></strong>: Runs during the 15-second autonomous period</li>
                <li><strong><code>usercontrol()</code></strong>: Runs during the 1-minute 45-second driver control period</li>
                <li><strong><code>pre_auton()</code></strong>: Setup code that runs before autonomous starts</li>
                <li><strong><code>main()</code></strong>: Initializes the competition and keeps the program running</li>
              </ul>

              <p>This structure is essential for VEX competitions - it automatically switches between autonomous and driver control based on the match timing.</p>

              <h2 id="setting-up-vexcode-in-vs-code">Setting Up VexCode in VS Code</h2>

              <h3>Step 1: Install Visual Studio Code</h3>
              <ol>
                <li>Download and install <a href="https://code.visualstudio.com/">Visual Studio Code</a></li>
                <li>Open VS Code and go to the Extensions view (Ctrl+Shift+X)</li>
                <li>Search for "VexCode" and install the official VexCode extension</li>
                <li>Restart VS Code after installation</li>
              </ol>

              <h3>Step 2: Create Your First VexCode Project</h3>
              <ol>
                <li>Open VS Code</li>
                <li>Go to File → New Folder and create a new project folder</li>
                <li>Open the Command Palette (Ctrl+Shift+P)</li>
                <li>Type "VexCode: New Project" and select it</li>
                <li>Choose "V5 Brain" as your device</li>
                <li>Select "C++" as your language</li>
                <li>Give your project a descriptive name</li>
              </ol>

              <h3>Step 3: Understanding the Project Structure</h3>
              <p>After creating a new project, you'll see this directory structure:</p>

              <pre><code class="language-cpp">MyRobotProject/
├── src/
│   ├── main.cpp              // Main program file
│   ├── robot-config.cpp      // Hardware configuration
│   └── robot-config.h        // Hardware declarations
├── include/
│   └── vex.h                 // VEX API header
├── .vscode/
│   └── settings.json         // VS Code project settings
└── README.md                 // Project documentation</code></pre>

              <p><strong>Key Files:</strong></p>
              <ul>
                <li><strong><code>main.cpp</code></strong>: Your main program with autonomous and user control functions</li>
                <li><strong><code>robot-config.cpp</code></strong>: All motor and sensor configurations in code</li>
                <li><strong><code>robot-config.h</code></strong>: Header file with device declarations</li>
                <li><strong><code>vex.h</code></strong>: VEX API library (automatically included)</li>
              </ul>

              <h2 id="code-based-hardware-configuration">Code-Based Hardware Configuration</h2>

              <p>Unlike the visual VexCode IDE, the VS Code extension requires you to configure all hardware through code. This approach gives you more control and makes your configuration part of your source code.</p>

              <h3>Motor Configuration in Code</h3>
              <p>All motors are configured in the <code>robot-config.cpp</code> file:</p>

              <pre><code class="language-cpp">// robot-config.cpp
#include "vex.h"

using namespace vex;

// Drive train motors
motor leftFront(PORT1, ratio18_1, false);   // Port 1, Red gear, not reversed
motor leftBack(PORT2, ratio18_1, false);    // Port 2, Red gear, not reversed
motor rightFront(PORT3, ratio18_1, true);   // Port 3, Red gear, reversed
motor rightBack(PORT4, ratio18_1, true);    // Port 4, Red gear, reversed

// Intake motor
motor intakeMotor(PORT5, ratio36_1, false); // Port 5, Green gear, not reversed

// Lift motor
motor liftMotor(PORT6, ratio6_1, false);    // Port 6, Blue gear, not reversed</code></pre>

              <p><strong>Configuration Parameters:</strong></p>
              <ul>
                <li><strong>Port</strong>: Which port on the V5 Brain (1-21)</li>
                <li><strong>Gear Setting</strong>: 
                  <ul>
                    <li><code>ratio18_1</code> - Red gear (fast, less torque)</li>
                    <li><code>ratio36_1</code> - Green gear (medium speed/torque)</li>
                    <li><code>ratio6_1</code> - Blue gear (slow, high torque)</li>
                  </ul>
                </li>
                <li><strong>Reversed</strong>: <code>true</code> if motor should spin opposite direction</li>
              </ul>

              <h3>Sensor Configuration in Code</h3>
              <p>Sensors are also configured in the <code>robot-config.cpp</code> file:</p>

              <pre><code class="language-cpp">// Encoders for tracking distance
encoder leftEncoder(PORT7, PORT8, false);  // Ports 7&8, not reversed
encoder rightEncoder(PORT9, PORT10, true); // Ports 9&10, reversed

// Gyro for turning
gyro gyroSensor(PORT11);

// Distance sensor
distance distanceSensor(PORT12);

// Color sensor
optical colorSensor(PORT13);

// Controller
controller Controller1(primary);</code></pre>

              <h3>Header File Declarations</h3>
              <p>The <code>robot-config.h</code> file contains all the declarations:</p>

              <pre><code class="language-cpp">// robot-config.h
#ifndef ROBOT_CONFIG_H
#define ROBOT_CONFIG_H

#include "vex.h"

// Motor declarations
extern motor leftFront;
extern motor leftBack;
extern motor rightFront;
extern motor rightBack;
extern motor intakeMotor;
extern motor liftMotor;

// Sensor declarations
extern encoder leftEncoder;
extern encoder rightEncoder;
extern gyro gyroSensor;
extern distance distanceSensor;
extern optical colorSensor;

// Controller declaration
extern controller Controller1;

#endif</code></pre>

              <h2 id="imu-sensor-setup-and-usage">IMU Sensor Setup and Usage</h2>

              <p>The Inertial Measurement Unit (IMU) is one of the most powerful sensors in VEX robotics. It provides precise orientation data that can be used for accurate turning, balancing, and navigation.</p>

              <h3>IMU Configuration</h3>
              <p>Add the IMU to your <code>robot-config.cpp</code> file:</p>

              <pre><code class="language-cpp">// robot-config.cpp
#include "vex.h"

using namespace vex;

// ... other motor and sensor configurations ...

// IMU sensor
inertial imuSensor(PORT14);  // Port 14</code></pre>

              <p>And declare it in your <code>robot-config.h</code> file:</p>

              <pre><code class="language-cpp">// robot-config.h
// ... other declarations ...

// IMU declaration
extern inertial imuSensor;</code></pre>

              <h3>IMU Calibration</h3>
              <p><strong>IMU calibration is critical and must be done in the <code>pre_auton()</code> function.</strong> The IMU needs time to calibrate before it can provide accurate readings.</p>

              <pre><code class="language-cpp">void pre_auton() {
    // Initialize sensors, reset encoders, etc.
    leftEncoder.resetPosition();
    rightEncoder.resetPosition();
    
    // CRITICAL: Calibrate IMU before autonomous starts
    imuSensor.calibrate();
    
    // Wait for calibration to complete (usually 1-2 seconds)
    while (imuSensor.isCalibrating()) {
        wait(10, msec);
    }
    
    // Optional: Reset heading to 0 degrees
    imuSensor.resetHeading();
    
    // Print calibration status to brain screen
    Brain.Screen.print("IMU Calibrated!");
}</code></pre>

              <blockquote>
                <p><strong>Important:</strong> Always check if the IMU is still calibrating before using it. Never use IMU values during calibration as they will be inaccurate.</p>
              </blockquote>

              <h3>IMU Methods and Usage</h3>
              <p>The IMU provides several useful methods for robot control:</p>

              <h4>Heading (Yaw) - Most Common</h4>
              <pre><code class="language-cpp">// Get current heading in degrees (0-360)
double currentHeading = imuSensor.heading();

// Reset heading to 0 degrees
imuSensor.resetHeading();

// Check if still calibrating
bool isCalibrating = imuSensor.isCalibrating();</code></pre>

              <h4>Roll and Pitch</h4>
              <pre><code class="language-cpp">// Get roll angle (left/right tilt)
double rollAngle = imuSensor.roll();

// Get pitch angle (forward/backward tilt)
double pitchAngle = imuSensor.pitch();</code></pre>

              <h4>Rotation (Total Degrees Turned)</h4>
              <pre><code class="language-cpp">// Get total rotation since last reset
double totalRotation = imuSensor.rotation();

// Reset rotation counter
imuSensor.resetRotation();</code></pre>

              <h3>Practical IMU Applications</h3>

              <h4>1. Precise Turning</h4>
              <pre><code class="language-cpp">void turnToAngle(double targetAngle) {
    double currentAngle = imuSensor.heading();
    double error = targetAngle - currentAngle;
    
    // Normalize error to -180 to 180 range
    while (error > 180) error -= 360;
    while (error < -180) error += 360;
    
    // Turn until within 2 degrees of target
    while (fabs(error) > 2) {
        // Calculate turn speed based on error
        double turnSpeed = error * 0.5;  // Proportional control
        if (turnSpeed > 50) turnSpeed = 50;
        if (turnSpeed < -50) turnSpeed = -50;
        
        // Apply turn
        leftFront.spin(forward, turnSpeed, percent);
        leftBack.spin(forward, turnSpeed, percent);
        rightFront.spin(reverse, turnSpeed, percent);
        rightBack.spin(reverse, turnSpeed, percent);
        
        // Update error
        currentAngle = imuSensor.heading();
        error = targetAngle - currentAngle;
        while (error > 180) error -= 360;
        while (error < -180) error += 360;
        
        wait(10, msec);
    }
    
    // Stop motors
    leftFront.stop();
    leftBack.stop();
    rightFront.stop();
    rightBack.stop();
}</code></pre>

              <h4>2. Straight Line Driving</h4>
              <pre><code class="language-cpp">void driveStraight(double distance, double speed) {
    // Reset encoders and IMU
    leftEncoder.resetPosition();
    rightEncoder.resetPosition();
    imuSensor.resetHeading();
    
    double targetDistance = distance * 360;  // Convert inches to degrees
    double currentDistance = 0;
    
    while (currentDistance < targetDistance) {
        // Get current heading for correction
        double currentHeading = imuSensor.heading();
        
        // Calculate correction (proportional control)
        double correction = currentHeading * 0.1;  // Adjust multiplier as needed
        
        // Apply correction to each side
        double leftSpeed = speed - correction;
        double rightSpeed = speed + correction;
        
        // Limit speeds
        if (leftSpeed > 100) leftSpeed = 100;
        if (leftSpeed < -100) leftSpeed = -100;
        if (rightSpeed > 100) rightSpeed = 100;
        if (rightSpeed < -100) rightSpeed = -100;
        
        // Drive motors
        leftFront.spin(forward, leftSpeed, percent);
        leftBack.spin(forward, leftSpeed, percent);
        rightFront.spin(forward, rightSpeed, percent);
        rightBack.spin(forward, rightSpeed, percent);
        
        // Update distance
        currentDistance = (leftEncoder.position(degrees) + rightEncoder.position(degrees)) / 2;
        
        wait(10, msec);
    }
    
    // Stop motors
    leftFront.stop();
    leftBack.stop();
    rightFront.stop();
    rightBack.stop();
}</code></pre>

              <h2 id="functions-in-vexcode">Functions in VEXcode</h2>

              <p>Functions are essential for organizing your code and making it reusable. They help break down complex tasks into manageable pieces and make your code easier to debug and maintain.</p>

              <h3>Why Functions Are Helpful</h3>
              <ul>
                <li><strong>Code Reusability</strong>: Write once, use many times</li>
                <li><strong>Organization</strong>: Break complex tasks into logical pieces</li>
                <li><strong>Debugging</strong>: Easier to test individual components</li>
                <li><strong>Readability</strong>: Make your main code cleaner and easier to understand</li>
                <li><strong>Teamwork</strong>: Different team members can work on different functions</li>
              </ul>

              <h3>Function Syntax in C++</h3>
              <pre><code class="language-cpp">// Function declaration
returnType functionName(parameter1, parameter2, ...) {
    // Function body
    // Do something with parameters
    return value;  // Optional, only if returnType is not void
}</code></pre>

              <h3>Common Function Examples</h3>

              <h4>1. Drive Control Functions</h4>
              <pre><code class="language-cpp">// Tank drive function
void tankDrive(int leftSpeed, int rightSpeed) {
    leftFront.spin(forward, leftSpeed, percent);
    leftBack.spin(forward, leftSpeed, percent);
    rightFront.spin(forward, rightSpeed, percent);
    rightBack.spin(forward, rightSpeed, percent);
}

// Arcade drive function
void arcadeDrive(int forwardSpeed, int turnSpeed) {
    int leftSpeed = forwardSpeed + turnSpeed;
    int rightSpeed = forwardSpeed - turnSpeed;
    
    // Limit speeds to valid range
    if (leftSpeed > 100) leftSpeed = 100;
    if (leftSpeed < -100) leftSpeed = -100;
    if (rightSpeed > 100) rightSpeed = 100;
    if (rightSpeed < -100) rightSpeed = -100;
    
    tankDrive(leftSpeed, rightSpeed);
}</code></pre>

              <h4>2. Intake Control Functions</h4>
              <pre><code class="language-cpp">// Intake control with speed parameter
void intakeControl(int speed) {
    if (speed > 0) {
        intakeMotor.spin(forward, speed, percent);
    } else if (speed < 0) {
        intakeMotor.spin(reverse, -speed, percent);
    } else {
        intakeMotor.stop();
    }
}

// Intake with automatic speed
void intakeIn() {
    intakeControl(80);  // 80% forward speed
}

void intakeOut() {
    intakeControl(-60); // 60% reverse speed
}

void intakeStop() {
    intakeControl(0);   // Stop
}</code></pre>

              <h4>3. Lift Control Functions</h4>
              <pre><code class="language-cpp">// Lift to specific height
void liftToHeight(double targetHeight) {
    double currentHeight = liftMotor.position(degrees);
    double error = targetHeight - currentHeight;
    
    // Lift until within 5 degrees of target
    while (fabs(error) > 5) {
        double liftSpeed = error * 0.3;  // Proportional control
        if (liftSpeed > 50) liftSpeed = 50;
        if (liftSpeed < -50) liftSpeed = -50;
        
        liftMotor.spin(forward, liftSpeed, percent);
        
        currentHeight = liftMotor.position(degrees);
        error = targetHeight - currentHeight;
        wait(10, msec);
    }
    
    liftMotor.stop();
}

// Preset lift positions
void liftToLow() {
    liftToHeight(0);      // Ground level
}

void liftToMedium() {
    liftToHeight(180);    // Medium height
}

void liftToHigh() {
    liftToHeight(360);    // High position
}</code></pre>

              <h4>4. Sensor Reading Functions</h4>
              <pre><code class="language-cpp">// Get average encoder distance
double getAverageDistance() {
    double leftDistance = leftEncoder.position(degrees);
    double rightDistance = rightEncoder.position(degrees);
    return (leftDistance + rightDistance) / 2;
}

// Check if object is detected
bool isObjectDetected() {
    return distanceSensor.objectDistance(inches) < 12;  // Within 12 inches
}

// Get robot heading with error checking
double getRobotHeading() {
    if (imuSensor.isCalibrating()) {
        return 0;  // Return 0 if still calibrating
    }
    return imuSensor.heading();
}</code></pre>

              <h3>Using Functions in Your Main Code</h3>
              <p>Here's how you might use these functions in your autonomous and user control:</p>

              <pre><code class="language-cpp">void autonomous() {
    // Drive forward 24 inches
    driveStraight(24, 50);
    
    // Turn 90 degrees right
    turnToAngle(90);
    
    // Intake a ball
    intakeIn();
    wait(1, seconds);
    intakeStop();
    
    // Lift to medium height
    liftToMedium();
    
    // Drive back
    driveStraight(-24, 50);
}

void usercontrol() {
    while (true) {
        // Tank drive using function
        int leftSpeed = Controller1.Axis3.position();
        int rightSpeed = Controller1.Axis2.position();
        tankDrive(leftSpeed, rightSpeed);
        
        // Intake control using functions
        if (Controller1.ButtonL1.pressing()) {
            intakeIn();
        } else if (Controller1.ButtonL2.pressing()) {
            intakeOut();
        } else {
            intakeStop();
        }
        
        // Lift control using functions
        if (Controller1.ButtonR1.pressing()) {
            liftToHigh();
        } else if (Controller1.ButtonR2.pressing()) {
            liftToLow();
        }
        
        wait(20, msec);
    }
}</code></pre>

              <h3>Function Best Practices</h3>
              <ul>
                <li><strong>Descriptive Names</strong>: Use clear, descriptive function names</li>
                <li><strong>Single Purpose</strong>: Each function should do one thing well</li>
                <li><strong>Parameters</strong>: Use parameters to make functions flexible</li>
                <li><strong>Comments</strong>: Document what each function does</li>
                <li><strong>Error Checking</strong>: Include safety checks in your functions</li>
                <li><strong>Consistent Style</strong>: Follow the same naming and formatting conventions</li>
              </ul>

              <h2 id="main-program-structure">Main Program Structure</h2>

              <p>Your main program in <code>main.cpp</code> follows this structure:</p>

              <pre><code class="language-cpp">// main.cpp
#include "vex.h"
#include "robot-config.h"

using namespace vex;

// Pre-autonomous setup function
void pre_auton() {
    // Initialize sensors, reset encoders, etc.
    // This runs before autonomous starts
    gyroSensor.calibrate();
    wait(2, seconds);
    
    leftEncoder.resetPosition();
    rightEncoder.resetPosition();
}

// Autonomous function - runs during 15-second autonomous period
void autonomous() {
    // Your autonomous routine goes here
    leftFront.spin(forward, 50, percent);
    leftBack.spin(forward, 50, percent);
    rightFront.spin(forward, 50, percent);
    rightBack.spin(forward, 50, percent);
    
    wait(2, seconds);
    
    leftFront.stop();
    leftBack.stop();
    rightFront.stop();
    rightBack.stop();
}

// User control function - runs during driver control period
void usercontrol() {
    while (true) {
        // Tank drive control
        int leftSpeed = Controller1.Axis3.position();
        int rightSpeed = Controller1.Axis2.position();
        
        leftFront.spin(forward, leftSpeed, percent);
        leftBack.spin(forward, leftSpeed, percent);
        rightFront.spin(forward, rightSpeed, percent);
        rightBack.spin(forward, rightSpeed, percent);
        
        // Intake control
        if (Controller1.ButtonL1.pressing()) {
            intakeMotor.spin(forward, 80, percent);
        } else if (Controller1.ButtonL2.pressing()) {
            intakeMotor.spin(reverse, 80, percent);
        } else {
            intakeMotor.stop();
        }
        
        wait(20, msec);  // Small delay to prevent overwhelming the brain
    }
}

// Main function - initializes competition
int main() {
    Competition.autonomous(autonomous);
    Competition.drivercontrol(usercontrol);
    
    pre_auton();
    
    while (true) {
        wait(100, msec);
    }
}</code></pre>

              <h2 id="building-and-uploading-your-code">Building and Uploading Your Code</h2>

              <h3>Building Your Project</h3>
              <ol>
                <li>In VS Code, open the Command Palette (Ctrl+Shift+P)</li>
                <li>Type "VexCode: Build" and select it</li>
                <li>The extension will compile your code and show any errors in the Problems panel</li>
                <li>Fix any compilation errors before proceeding</li>
              </ol>

              <h3>Uploading to the V5 Brain</h3>
              <ol>
                <li>Connect your V5 Brain to your computer via USB</li>
                <li>Make sure the Brain is powered on</li>
                <li>In VS Code, open the Command Palette (Ctrl+Shift+P)</li>
                <li>Type "VexCode: Download" and select it</li>
                <li>The extension will upload your compiled code to the Brain</li>
              </ol>

              <h2 id="next-steps">Next Steps</h2>

              <p>Now that you understand the basics of VexCode in VS Code:</p>
              <ol>
                <li><strong>Practice</strong>: Create a simple program that drives forward and backward</li>
                <li><strong>Experiment</strong>: Try different motor speeds and directions</li>
                <li><strong>Add sensors</strong>: Incorporate encoders or gyros into your programs</li>
                <li><strong>Build complexity</strong>: Combine multiple behaviors into autonomous routines</li>
                <li><strong>Use Git</strong>: Start tracking your code changes with version control</li>
              </ol>

              <p><strong>Ready to start coding?</strong> You now have a comprehensive understanding of VEXcode and are ready to build sophisticated robot programs.</p>

              <p><strong>Continue Learning:</strong></p>
              <ul>
                <li>Move on to <a href="cs-overview.html">Computer Science Overview</a> for deeper programming concepts</li>
                <li>Jump to <a href="advanced-robotics-programming.html">Advanced Robotics Programming</a> for sophisticated control systems</li>
                <li>Practice with real robot hardware to solidify your understanding</li>
              </ul>

              <p>Remember: The best way to learn VEX programming is by doing. Start with simple programs, build your confidence, and gradually tackle more complex challenges. Every expert was once a beginner! 🤖</p>
            </div>
          </article>
        </main>
      </div>
    </div>
  </main>

  <footer class="site-footer h-card">
    <data class="u-url" href="index.html"></data>

    <div class="wrapper">
      <div class="footer-col-wrapper">
        <div class="footer-col footer-col-1">
          <ul class="contact-list">
            <li class="p-name">Harvard-Westlake VEX Robotics</li>
            <li><a class="u-email" href="mailto:hakopzarikyan@gmail.com">hakopzarikyan@gmail.com</a></li>
          </ul>
        </div>

        <div class="footer-col footer-col-2">
          <!-- Social links can be added here -->
        </div>

        <div class="footer-col footer-col-3">
          <p>Curriculum and updates for Harvard‑Westlake VEX Robotics.</p>
        </div>
      </div>
    </div>
  </footer>

  <script>
  document.addEventListener('DOMContentLoaded', function() {
    // Generate sidebar navigation from headings (only h2 - main sections)
    const content = document.querySelector('.post-content');
    const headings = content.querySelectorAll('h2');
    const navList = document.getElementById('sidebar-nav-list');
    
    if (headings.length === 0) {
      // Fallback navigation based on page title
      const fallbackNav = getFallbackNavigation('VexCode Introduction');
      navList.innerHTML = fallbackNav;
      return;
    }
    
    // Clear existing navigation
    navList.innerHTML = '';
    
    headings.forEach(function(heading) {
      // Create ID if it doesn't exist
      if (!heading.id) {
        heading.id = heading.textContent
          .toLowerCase()
          .replace(/[^a-z0-9\s-]/g, '')
          .replace(/\s+/g, '-')
          .replace(/-+/g, '-')
          .trim();
      }
      
      // Create navigation item
      const li = document.createElement('li');
      const a = document.createElement('a');
      a.href = '#' + heading.id;
      a.textContent = heading.textContent;
      
      // Add active class styling
      a.addEventListener('click', function(e) {
        // Remove active class from all links
        navList.querySelectorAll('a').forEach(link => link.classList.remove('active'));
        // Add active class to clicked link
        this.classList.add('active');
      });
      
      li.appendChild(a);
      navList.appendChild(li);
    });
    
    // Highlight active section on scroll
    const observer = new IntersectionObserver(function(entries) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          // Remove active class from all links
          navList.querySelectorAll('a').forEach(link => link.classList.remove('active'));
          
          // Add active class to corresponding link
          const activeLink = navList.querySelector('a[href="#' + entry.target.id + '"]');
          if (activeLink) {
            activeLink.classList.add('active');
          }
        }
      });
    }, {
      rootMargin: '-20% 0px -70% 0px'
    });
    
    headings.forEach(function(heading) {
      observer.observe(heading);
    });
  });

  function getFallbackNavigation(pageTitle) {
    const navMaps = {
      'VexCode Introduction': `
        <li><a href="#what-is-vexcode">What is VexCode?</a></li>
        <li><a href="#competition-program-structure">Competition Program Structure</a></li>
        <li><a href="#setting-up-vexcode-in-vs-code">Setting Up VexCode in VS Code</a></li>
        <li><a href="#code-based-hardware-configuration">Code-Based Hardware Configuration</a></li>
        <li><a href="#imu-sensor-setup-and-usage">IMU Sensor Setup and Usage</a></li>
        <li><a href="#functions-in-vexcode">Functions in VEXcode</a></li>
        <li><a href="#main-program-structure">Main Program Structure</a></li>
        <li><a href="#building-and-uploading-your-code">Building and Uploading Your Code</a></li>
        <li><a href="#next-steps">Next Steps</a></li>
      `
    };
    
    return navMaps[pageTitle] || '<li><a href="#top">Page Navigation</a></li>';
  }
  </script>
  
  <!-- Prism.js for syntax highlighting -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  <script>
    // Apply theme-specific syntax highlighting
    function applySyntaxHighlighting() {
      const theme = localStorage.getItem('hw-vexcode-theme') || 
                   (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
      
      // Remove existing theme classes
      document.querySelectorAll('link[href*="prism"]').forEach(link => {
        if (link.href.includes('prism-tomorrow') || link.href.includes('prism.min')) {
          link.disabled = true;
        }
      });
      
      // Apply appropriate theme
      if (theme === 'dark') {
        document.querySelector('link[href*="prism-tomorrow"]').disabled = false;
      } else {
        document.querySelector('link[href*="prism.min"]').disabled = false;
      }
      
      // Re-highlight code blocks
      if (window.Prism) {
        Prism.highlightAll();
      }
    }
    
    // Apply highlighting on page load
    document.addEventListener('DOMContentLoaded', function() {
      // Add custom VEX type highlighting
      if (window.Prism) {
        // Add VEX-specific keywords to C++ language
        Prism.languages.cpp.keyword = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char8_t|char16_t|char32_t|class|concept|const|consteval|constexpr|constinit|const_cast|continue|co_await|co_return|co_yield|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|false|float|for|friend|goto|if|inline|int|long|mutable|namespace|new|noexcept|nullptr|operator|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|true|try|typedef|typeid|typename|union|unsigned|using|virtual|void|volatile|wchar_t|while|motor|inertial|encoder|gyro|distance|optical|controller|brain|competition)\b/;
      }
      
      applySyntaxHighlighting();
    });
    
    // Listen for theme changes
    window.addEventListener('storage', function(e) {
      if (e.key === 'hw-vexcode-theme') {
        applySyntaxHighlighting();
      }
    });
  </script>
</body>
</html>
